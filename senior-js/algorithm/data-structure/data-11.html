<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>11.递归：求解汉诺塔问题 | 一只无聊的柠檬</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/img/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.3c3b5dfb.css" as="style"><link rel="preload" href="/assets/js/app.edd6bd2d.js" as="script"><link rel="preload" href="/assets/js/2.cff21c2a.js" as="script"><link rel="preload" href="/assets/js/13.54f5db56.js" as="script"><link rel="prefetch" href="/assets/js/10.1ef3d16c.js"><link rel="prefetch" href="/assets/js/11.055e6f83.js"><link rel="prefetch" href="/assets/js/12.afadf4ed.js"><link rel="prefetch" href="/assets/js/14.0552eb89.js"><link rel="prefetch" href="/assets/js/15.439b8ec4.js"><link rel="prefetch" href="/assets/js/16.45d334e7.js"><link rel="prefetch" href="/assets/js/17.87d4454d.js"><link rel="prefetch" href="/assets/js/18.6e86e7af.js"><link rel="prefetch" href="/assets/js/19.c13ae854.js"><link rel="prefetch" href="/assets/js/20.50b7c537.js"><link rel="prefetch" href="/assets/js/21.107a76a4.js"><link rel="prefetch" href="/assets/js/22.8d3de896.js"><link rel="prefetch" href="/assets/js/23.2813ff38.js"><link rel="prefetch" href="/assets/js/24.4953e3aa.js"><link rel="prefetch" href="/assets/js/25.6d8da92f.js"><link rel="prefetch" href="/assets/js/26.d0ff48ea.js"><link rel="prefetch" href="/assets/js/27.b139f8ae.js"><link rel="prefetch" href="/assets/js/28.4b81fe24.js"><link rel="prefetch" href="/assets/js/29.5194f36c.js"><link rel="prefetch" href="/assets/js/3.01d9f5e2.js"><link rel="prefetch" href="/assets/js/30.bbad0aed.js"><link rel="prefetch" href="/assets/js/31.4c775510.js"><link rel="prefetch" href="/assets/js/32.3585bf93.js"><link rel="prefetch" href="/assets/js/33.a1d4b45f.js"><link rel="prefetch" href="/assets/js/34.a11070a9.js"><link rel="prefetch" href="/assets/js/35.d1f27671.js"><link rel="prefetch" href="/assets/js/36.6ec8fc66.js"><link rel="prefetch" href="/assets/js/37.2941c504.js"><link rel="prefetch" href="/assets/js/38.26b576f1.js"><link rel="prefetch" href="/assets/js/4.d4d02f50.js"><link rel="prefetch" href="/assets/js/5.72f0dc7f.js"><link rel="prefetch" href="/assets/js/6.f6241ffb.js"><link rel="prefetch" href="/assets/js/7.638b176e.js"><link rel="prefetch" href="/assets/js/8.a027d131.js"><link rel="prefetch" href="/assets/js/9.d19fda0c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3c3b5dfb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">一只无聊的柠檬</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/senior-js/guide/" class="nav-link">
  工作总结
</a></div><div class="nav-item"><a href="/senior-js/algorithm/" class="nav-link router-link-active">
  自学记录
</a></div><div class="nav-item"><a href="/senior-js/readDoc/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/senior-js/other/" class="nav-link">
  杂谈
</a></div><div class="nav-item"><a href="https://github.com/fanyuyingbest" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/senior-js/guide/" class="nav-link">
  工作总结
</a></div><div class="nav-item"><a href="/senior-js/algorithm/" class="nav-link router-link-active">
  自学记录
</a></div><div class="nav-item"><a href="/senior-js/readDoc/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/senior-js/other/" class="nav-link">
  杂谈
</a></div><div class="nav-item"><a href="https://github.com/fanyuyingbest" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/senior-js/algorithm/" class="sidebar-link">知识体系梳理</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2020年</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/senior-js/algorithm/data-structure/" class="sidebar-heading clickable router-link-active open"><span>数据结构-拉钩教育</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/senior-js/algorithm/data-structure/data-1.html" class="sidebar-link">1.复杂度：如何衡量程序运行的效率？</a></li><li><a href="/senior-js/algorithm/data-structure/data-2.html" class="sidebar-link">2.数据结构：时间复杂度👉空间复杂度</a></li><li><a href="/senior-js/algorithm/data-structure/data-3.html" class="sidebar-link">3.增删查：掌握数据结构基本操作</a></li><li><a href="/senior-js/algorithm/data-structure/data-4.html" class="sidebar-link">4.如何完成线性表结构下的增删查</a></li><li><a href="/senior-js/algorithm/data-structure/data-5.html" class="sidebar-link">5.栈：后进先出线性表实现增删查</a></li><li><a href="/senior-js/algorithm/data-structure/data-6.html" class="sidebar-link">6.队列：先进先出线性表实现增删查</a></li><li><a href="/senior-js/algorithm/data-structure/data-7.html" class="sidebar-link">7.数组：如何实现基本索引的查找</a></li><li><a href="/senior-js/algorithm/data-structure/data-8.html" class="sidebar-link">8.字符串：解决字符串匹配算法</a></li><li><a href="/senior-js/algorithm/data-structure/data-9.html" class="sidebar-link">9.树和二叉树：如何实现增删改查</a></li><li><a href="/senior-js/algorithm/data-structure/data-10.html" class="sidebar-link">10.哈希表：高效率查找的利器</a></li><li><a href="/senior-js/algorithm/data-structure/data-11.html" class="active sidebar-link">11.递归：求解汉诺塔问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/senior-js/algorithm/data-structure/data-12.html" class="sidebar-link">12.分治：利用分治法完成数据查找</a></li><li><a href="/senior-js/algorithm/data-structure/data-13.html" class="sidebar-link">13.排序：经典排序算法原理解析与对比</a></li><li><a href="/senior-js/algorithm/data-structure/data-14.html" class="sidebar-link">14.动态规划：最优结构解决复杂问题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/senior-js/algorithm/training/" class="sidebar-heading clickable"><span>每日一题</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_11-递归：求解汉诺塔问题"><a href="#_11-递归：求解汉诺塔问题" class="header-anchor">#</a> 11.递归：求解汉诺塔问题</h1> <blockquote><p>不论是数据结构还是算法思维，他们的目标都是降低时间复杂度，数据结构是从数据组织形式的角度达成这个目标，而算法思维是从数据处理的思路上去达成这个目标</p></blockquote> <blockquote><p>举例来说，虽然选择了一个高效率的数据结构去处理问题，但是如果数据处理的逻辑上出现缺陷，仍会产生很多无效计算，造成时间浪费</p></blockquote> <h3 id="_11-1-什么是递归"><a href="#_11-1-什么是递归" class="header-anchor">#</a> 11-1 什么是递归</h3> <blockquote><p>在数学与计算机科学中，递归是指在函数的定义中使用函数自身的方法，直观上来看，就是某个函数调用自己<br>
递归有两层含义</p></blockquote> <ul><li>递归问题必须可以分解为若干个规模小、与原问题形式相同的子问题；并且这些子问题可以用完全相同的解题思路来解决</li> <li>递归问题的演化过程是一个对原问题从大到小进行拆解的过程，并且会有一个明确的终点(临界点)；一旦原问题达到这个临界点，就不用再往更小的问题拆解了。最后，从这个临界点开始，把小问题的答案按照原路返回，原问题得以解决</li></ul> <blockquote><p>简言之，递归的基本思想就是把规模大的问题转化为规模小的相同的子问题来解决。因为大问题小问题的解决方法是同一个方法，这就产生了函数调用它自身的情况，这也是递归的定义所在。</p></blockquote> <blockquote><p>格外注意的是，这个解决问题的函数必须有明确的结束条件，否则就无导致递归的情况，总结起来：<b>递归的实现包含了两个部分，一个是递归主题，另一个是终止条件</b></p></blockquote> <h3 id="_11-2-递归的算法思想"><a href="#_11-2-递归的算法思想" class="header-anchor">#</a> 11-2 递归的算法思想</h3> <blockquote><p>递归的数学模型其实就是数学归纳法，这个证明方法就是我们高中时期经常解决的数列问题<br>
一个常见的题目是：证明当n等于任意一个自然数时某命题成立。<br>
采用数学归纳法，证明分为以下两个步骤</p></blockquote> <ul><li>1.证明当n = 1 命题成立</li> <li>2.假设n=m命题成立，那么尝试推导出n = m + 1时，命题也成立</li></ul> <blockquote><p>与数学归纳法类似，当采用递归算法解决问题时，我们也需要围绕这两个步骤去做文章</p></blockquote> <ul><li>1.当你面对一个大规模问题时，如何把它分解为几个小规模的同样问题</li> <li>2.当你把问题通过多轮分解后，最终的结果，也就是终止条件如何定义</li></ul> <blockquote><p>所以当一个问题同时满足以下2个条件时，就可以使用递归方法求解</p></blockquote> <ul><li>可以拆解为除了数据闺蜜外，求解思路完全相同的子问题</li> <li>存在终止条件</li></ul> <blockquote><p>在树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树<br>
当某个结点没有左子树和右子树时，则直接打印结点，完成终止；所以树的中序遍历完全可以通过递归实现</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>  //中序遍历
  function inOrderTraverse(Node node){
    if(node == null){return};
    inOrderTraverse(node.left)
    document.write(node.data + '')
    inOrderTraverse(node.right)
  }
</code></pre></div><blockquote><p>以上就是递归的算法思想，<b>写出递归代码的管家在于，写出递推公式和找出终止条件</b></p></blockquote> <blockquote><p>也就是说我们需要：先将大问题分解成小问题的规律，并基于此写出递推公式；然后找出终止条件，就是但找到最简单的问题时，如何写出答案；最终将递推公式和终止条件翻译成实际代码</p></blockquote> <h3 id="_11-3-递归的案例"><a href="#_11-3-递归的案例" class="header-anchor">#</a> 11-3 递归的案例</h3> <blockquote><p>汉诺塔问题：大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上，并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘<br>
我们把这个问题抽象为一个数学问题：从左到右有x,y,z三根柱子，其中x柱子上面有从小叠到大的n个圆盘。现要求将x柱子上的圆盘移动到z柱子上去，要求是每次只能移动一个盘子，且大盘子不能被放在小盘子上面，求移动步骤。<br>
我们可以将这个大问题拆解为3个小问题</p></blockquote> <ul><li>1.把从小到大的n-1个盘子，从x移动到y</li> <li>2.接着把最大的一个盘子，从x移动到z</li> <li>3.再把从小到大的n-1个盘子，从y移动到z</li></ul> <blockquote><p><b>首先，我们判断它是否满足递归的第一个条件：</b>其中1和3就是汉诺塔问题，我们定义好了递归体，也就是满足了递归的第一个条件。<br></p></blockquote> <blockquote><p><b>接下来，我们判断它是否满足终止条件：</b>随着递归体不断缩小范围，汉诺塔问题由原来‘移动从小到大的n个盘子’，缩小为‘移动从小到大的n-1个盘子’.移动从小到大的1个盘子，就是最小的盘子，根据规则可以发现，最小的盘子，是可以自由移动的，因此，递归的第二个条件，终止条件也是满足的。<br>
我们定义汉诺塔的递归函数为hanoi(),这个函数的输入参数包含了：</p></blockquote> <ul><li>3根柱子的标记x,y,z</li> <li>等待移动的盘子数量</li></ul> <blockquote><p>具体代码如下：</p></blockquote> <ul><li>1.把从小到大的n-1个盘子从x移动到y,那么代码就是hanoi(n-1,x,y,z)</li> <li>2.再把最大的一个盘子从x移动到z,那么直接完成一次移动的动作就可以了</li> <li>3.再把从小到大的n-1个盘子从y移动到z,那么代码就是hanio(n-1,y,x,z).对于终止条件这需要判断n的大小，如果n等于1，那么同样直接移动就可以了</li></ul> <div class="language- extra-class"><pre class="language-text"><code> function main(String[] args){
   let x = 'x';
   let y = 'y';
   let z = 'z';
   hanio(3,x,y,z)
 };
 function hanoi(n,x,y,z){
   if(n&lt;1){
     document.write('汉诺塔车层数不能小于1')
   }else if(n == 1){
     document.write(`移动：${x}-&gt;${z}`);
     return;
   }else{
     hanio(n-1,x,z,y);
     document.write(`移动：${x}-&gt;${z}`);
     hanio(n-1,y,x,z)
   }
 }
</code></pre></div><blockquote><p>我们以n=3为例，执行一下这段代码：<br></p></blockquote> <p><img src="/img/2020/algorithm/11-1.gif" alt="图示"></p> <blockquote><p>最终梳理一下，代码执行结果就是：</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>  移动: x-&gt;z

  移动: x-&gt;y

  移动: z-&gt;y

  移动: x-&gt;z

  移动: y-&gt;x

  移动: y-&gt;z

  移动: x-&gt;z
</code></pre></div><blockquote><p>抛开用于处理输入异常的代码部分不谈，它的代码包含了两个部分</p></blockquote> <ul><li>1.终止条件，即如何处理小规模的问题，实现的代码量一定是很少的</li> <li>2.递归体，即大问题向小问题分解的过程，实现的代码量也不会太多</li></ul> <blockquote><p>所以，一个复杂问题的递归实现，通常代码量都不回太多</p></blockquote> <h3 id="_11-4-总结"><a href="#_11-4-总结" class="header-anchor">#</a> 11-4 总结</h3> <p><b>递归的核心思想是把规模大的问题转化为规模小的相似的子问题来解决</b></p> <ul><li>在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况</li> <li>这个解决问题的函数必须有明显的结束条件，这样就不会产生无限递归的情况</li> <li>递归有很多使用的地方，例如：分治策略，快速排序等</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/senior-js/algorithm/data-structure/data-10.html" class="prev">
        10.哈希表：高效率查找的利器
      </a></span> <span class="next"><a href="/senior-js/algorithm/data-structure/data-12.html">
        12.分治：利用分治法完成数据查找
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.edd6bd2d.js" defer></script><script src="/assets/js/2.cff21c2a.js" defer></script><script src="/assets/js/13.54f5db56.js" defer></script>
  </body>
</html>
