<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>8.字符串：解决字符串匹配算法 | 一只无聊的柠檬</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/img/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.3c3b5dfb.css" as="style"><link rel="preload" href="/assets/js/app.edd6bd2d.js" as="script"><link rel="preload" href="/assets/js/2.cff21c2a.js" as="script"><link rel="preload" href="/assets/js/23.2813ff38.js" as="script"><link rel="prefetch" href="/assets/js/10.1ef3d16c.js"><link rel="prefetch" href="/assets/js/11.055e6f83.js"><link rel="prefetch" href="/assets/js/12.afadf4ed.js"><link rel="prefetch" href="/assets/js/13.54f5db56.js"><link rel="prefetch" href="/assets/js/14.0552eb89.js"><link rel="prefetch" href="/assets/js/15.439b8ec4.js"><link rel="prefetch" href="/assets/js/16.45d334e7.js"><link rel="prefetch" href="/assets/js/17.87d4454d.js"><link rel="prefetch" href="/assets/js/18.6e86e7af.js"><link rel="prefetch" href="/assets/js/19.c13ae854.js"><link rel="prefetch" href="/assets/js/20.50b7c537.js"><link rel="prefetch" href="/assets/js/21.107a76a4.js"><link rel="prefetch" href="/assets/js/22.8d3de896.js"><link rel="prefetch" href="/assets/js/24.4953e3aa.js"><link rel="prefetch" href="/assets/js/25.6d8da92f.js"><link rel="prefetch" href="/assets/js/26.d0ff48ea.js"><link rel="prefetch" href="/assets/js/27.b139f8ae.js"><link rel="prefetch" href="/assets/js/28.4b81fe24.js"><link rel="prefetch" href="/assets/js/29.5194f36c.js"><link rel="prefetch" href="/assets/js/3.01d9f5e2.js"><link rel="prefetch" href="/assets/js/30.bbad0aed.js"><link rel="prefetch" href="/assets/js/31.4c775510.js"><link rel="prefetch" href="/assets/js/32.3585bf93.js"><link rel="prefetch" href="/assets/js/33.a1d4b45f.js"><link rel="prefetch" href="/assets/js/34.a11070a9.js"><link rel="prefetch" href="/assets/js/35.d1f27671.js"><link rel="prefetch" href="/assets/js/36.6ec8fc66.js"><link rel="prefetch" href="/assets/js/37.2941c504.js"><link rel="prefetch" href="/assets/js/38.26b576f1.js"><link rel="prefetch" href="/assets/js/4.d4d02f50.js"><link rel="prefetch" href="/assets/js/5.72f0dc7f.js"><link rel="prefetch" href="/assets/js/6.f6241ffb.js"><link rel="prefetch" href="/assets/js/7.638b176e.js"><link rel="prefetch" href="/assets/js/8.a027d131.js"><link rel="prefetch" href="/assets/js/9.d19fda0c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3c3b5dfb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">一只无聊的柠檬</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/senior-js/guide/" class="nav-link">
  工作总结
</a></div><div class="nav-item"><a href="/senior-js/algorithm/" class="nav-link router-link-active">
  自学记录
</a></div><div class="nav-item"><a href="/senior-js/readDoc/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/senior-js/other/" class="nav-link">
  杂谈
</a></div><div class="nav-item"><a href="https://github.com/fanyuyingbest" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/senior-js/guide/" class="nav-link">
  工作总结
</a></div><div class="nav-item"><a href="/senior-js/algorithm/" class="nav-link router-link-active">
  自学记录
</a></div><div class="nav-item"><a href="/senior-js/readDoc/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/senior-js/other/" class="nav-link">
  杂谈
</a></div><div class="nav-item"><a href="https://github.com/fanyuyingbest" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/senior-js/algorithm/" class="sidebar-link">知识体系梳理</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2020年</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/senior-js/algorithm/data-structure/" class="sidebar-heading clickable router-link-active open"><span>数据结构-拉钩教育</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/senior-js/algorithm/data-structure/data-1.html" class="sidebar-link">1.复杂度：如何衡量程序运行的效率？</a></li><li><a href="/senior-js/algorithm/data-structure/data-2.html" class="sidebar-link">2.数据结构：时间复杂度👉空间复杂度</a></li><li><a href="/senior-js/algorithm/data-structure/data-3.html" class="sidebar-link">3.增删查：掌握数据结构基本操作</a></li><li><a href="/senior-js/algorithm/data-structure/data-4.html" class="sidebar-link">4.如何完成线性表结构下的增删查</a></li><li><a href="/senior-js/algorithm/data-structure/data-5.html" class="sidebar-link">5.栈：后进先出线性表实现增删查</a></li><li><a href="/senior-js/algorithm/data-structure/data-6.html" class="sidebar-link">6.队列：先进先出线性表实现增删查</a></li><li><a href="/senior-js/algorithm/data-structure/data-7.html" class="sidebar-link">7.数组：如何实现基本索引的查找</a></li><li><a href="/senior-js/algorithm/data-structure/data-8.html" class="active sidebar-link">8.字符串：解决字符串匹配算法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/senior-js/algorithm/data-structure/data-9.html" class="sidebar-link">9.树和二叉树：如何实现增删改查</a></li><li><a href="/senior-js/algorithm/data-structure/data-10.html" class="sidebar-link">10.哈希表：高效率查找的利器</a></li><li><a href="/senior-js/algorithm/data-structure/data-11.html" class="sidebar-link">11.递归：求解汉诺塔问题</a></li><li><a href="/senior-js/algorithm/data-structure/data-12.html" class="sidebar-link">12.分治：利用分治法完成数据查找</a></li><li><a href="/senior-js/algorithm/data-structure/data-13.html" class="sidebar-link">13.排序：经典排序算法原理解析与对比</a></li><li><a href="/senior-js/algorithm/data-structure/data-14.html" class="sidebar-link">14.动态规划：最优结构解决复杂问题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/senior-js/algorithm/training/" class="sidebar-heading clickable"><span>每日一题</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_8-字符串：解决字符串匹配算法"><a href="#_8-字符串：解决字符串匹配算法" class="header-anchor">#</a> 8.字符串：解决字符串匹配算法</h1> <h3 id="_8-1-字符串是什么"><a href="#_8-1-字符串是什么" class="header-anchor">#</a> 8-1 字符串是什么</h3> <blockquote><p>字符串是由n个字符组成的一个有序整体(n &gt;= 0);字符串的逻辑结构和线性表相似，不同子处在于字符串针对字符集，也就是字符串中的元素都是字符，线性表则没有这些限制</p></blockquote> <blockquote><p>在实际操作中，我们经常会用到一些特殊字符：</p></blockquote> <ul><li>空串，指含有零个字符串，如：s = '',书面可以直接用Ø表示</li> <li>空格串，只包含空格的字符串，它和空串是不一样的，可以包含多个空格，如 s = '   ',就包含了3个空格</li> <li>子串，串中任意连续字符组成的字符串叫做该串的子串</li> <li>原串通常也叫做主串，例如 a = 'BEI',b='BEIJING',c='BJINGEI'</li> <li>对于子字符串a和b来说，b中含有a，所以可以称a是b的子串，b是a的主串</li> <li>而c与a而言，虽然c中也含有a的全部字符，但是不是连续的'BEI'，所以c和a没有任何关系</li></ul> <blockquote><p>只有两个字符串的串值完全相同，这两个串才相等<br>
字符串的存储结构与线性表相同，也有顺序存储链式存储两种</p></blockquote> <ul><li>字符串的顺序存储结构，是一组地址连续的存储单元来存储串中的字符序列，一般是用定长数组来实现，有些语言会用\0来表示串值终结</li> <li>字符串的链式存储结构，与线性表相似，但由于串结构的特殊性，如果也简单的将每个链结点存储为一个字符，会造成很大的空间浪费。因此，一个结点可以考了放多个字符，如果最后一个未被占满时，可以使用“#”或其他非串值字符补全</li></ul> <p><img src="/img/2020/algorithm/data8-1.png" alt="图示"></p> <blockquote><p>在链式存储中，每个结点设置字符数量多少，与串的长度、可以占用的存储空间以及程序实现的功能相关</p></blockquote> <ul><li>如果字符串中包含的数据量很大，但是可用的存储空间有限，那么就需要提高空间利用率，相应的减少结点数量</li> <li>而如果程序中存在大量插入、删除数据，如果每个结点包含的字符过多，操作字符就会变得很麻烦，为实现功能增加了障碍</li></ul> <blockquote><p>因此，串的链式存储结构，除了在连接串与串操作时有一定的方便之处，总的说来，不如顺序存储灵活，在性能方面也不如顺序结构好存储</p></blockquote> <h3 id="_8-2-字符串的基本操作"><a href="#_8-2-字符串的基本操作" class="header-anchor">#</a> 8-2 字符串的基本操作</h3> <ul><li>字符串的和线性表操作很相似，区别在于，所有元素都是字符</li> <li>线性表更关注单个元素的操作，如增删查；字符串更关注的是查找子串的位置、替换等操作</li></ul> <h4 id="_8-2-1-字符串的新增操作"><a href="#_8-2-1-字符串的新增操作" class="header-anchor">#</a> 8-2-1 字符串的新增操作</h4> <ul><li>字符串的新增操作和数组相似，都牵扯插入字符串之后字符的移挪操作，所以时间复杂度为O(n)</li> <li>如果在字符串s1='123456' 正中间插入一个字符串s2='abc'，则需要将456向后挪移3个字符位置，再插入</li> <li>也存在一种特殊情况，比如再s1后面插入s2，则不需要移动位置，这时的时间复杂度为O(1)</li></ul> <h4 id="_8-2-2-字符串的删除操作"><a href="#_8-2-2-字符串的删除操作" class="header-anchor">#</a> 8-2-2 字符串的删除操作</h4> <ul><li>字符串的删除与数组的删除类似，也会牵扯到删除字符后的字符移挪操作，所以时间复杂度为O(n)</li> <li>如果在字符串s1='123456' 正中间删除一个字符串s2='34'，则需要将56需要向前挪移2个字符位置，时间复杂度为O(n)</li> <li>也存在一种特殊情况，比如再s1删除56，则不需要移动位置，这时的时间复杂度为O(1)</li></ul> <h4 id="_8-2-3-字符串的查找操作"><a href="#_8-2-3-字符串的查找操作" class="header-anchor">#</a> 8-2-3 字符串的查找操作</h4> <blockquote><p>字符串s='goodgoogle',判断字符串t='google'在s中是否存在。这里要判断的不仅是字符是否存在，而且必须是连续的</p></blockquote> <h5 id="_8-2-3-1-子串查找-字符串匹配"><a href="#_8-2-3-1-子串查找-字符串匹配" class="header-anchor">#</a> 8-2-3-1 子串查找(字符串匹配)</h5> <blockquote><p>我们把主串的长度记为n，子串的长度为m，在主串里面找子串，且n是大于m的，所以字符串匹配的时间复杂度就是n和m的函数<br>
主字符串为s='goodgoogle',子字符串为t = 'google'</p></blockquote> <ul><li>首先，我么么从主串s的第一位开始，判断s的第1个字符是否与t的第一个字符相等</li> <li>如果不想等，则继续判断主串的第2个字符与t的第一个是否相等，直到在s中找到与t第一个字符相等的字符时，再判断之后的字符是否与t后续字符相等</li> <li>如果持续相等直到t的最后一个字符，则匹配成功</li> <li>如果发现一个不等的字符，则重新回到前面的步骤，查找s中是否有与t的第一个字符相等</li> <li>s的第1个字符与t的第一个字符相等，则开始匹配的后续，但第4个字符匹配失败，则回到主串继续和t的第一个字符匹配</li></ul> <blockquote><p>这种匹配方法，需要两层循环，第一层循环，去查找第一个字符相等的位置；第二层循环基于此去匹配后续字符是否相等，这样时间复杂度就变为O(nm)</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code> function s8_1(){
   let s = 'goodgoogle';//主串
   let t = 'google';//子串
   let isFind = 0;//是否有匹配
   //a串第一个循环，注意，一般循环到第5位的时候，就不需要往后循环了，因为长度都已经不匹配了
   for(let i = 0;i&lt; (s.length - t.length + 1); i++){
     //第一位是否匹配
     if(s.charAt(i) == t.charAt(0)){
       //记录相等时的字符长度
        let jc = 0;
        for(let j=0;j&lt;t.length;j++){
          //如果出现字段不等时，跳出循环
          if(s.charAt(i+j) != t.charAt(j)){
            break;
          }
          //相等字符长度
          jc = j;
        }
        //如果相等的字符最后一位index与t的最后一位index一致，则符合要求
        if(jc == t.length - 1){
          isFind = 1;
        }
     }; 
   };
   //返回最终结果
   return isFind;
 }
</code></pre></div><h3 id="_8-3-字符串匹配算法的案例"><a href="#_8-3-字符串匹配算法的案例" class="header-anchor">#</a> 8-3 字符串匹配算法的案例</h3> <blockquote><p>假设有且仅有一个最大公共子串，比如a='13452439',b='123456',由于都包含456，则同时出现在a和b字符串中最长的子串为‘345’<br>
假设a的长度为n，b的长度为m,可见时间复杂度是m和n的函数</p></blockquote> <ul><li>首先，需要对a和b找到第一个共同出现的字符</li> <li>然后，一旦找到第一个匹配的字符后，就可以同时在a和b中继续它后续的字符是否相等</li> <li>这样，a和b都会被访问一次，全局还需要维护一个最长的子串变量</li></ul> <blockquote><p>从代码结构来看，第一步需要俩层循环找到共同出现的字符，这就是O(mn)<br>
一旦找到，就需要继续查找共同出现的字符串，这就又潜套了一层循环，可见最终的时间复杂度为O(nm<sup>2</sup>)</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>  function s8_2(){
    let b = '13452439';
    let a = '123456';
    let maxLength_str = '';
    let max_len = 0;
    //先循环对比第一个字符是否相等
    for(let i = 0; i &lt; a.length;i++){
      for(let j = 0; j &lt; b.length;j++){
        //找到出现第一个相同字符的位置
        if(a.charAt(i) == b.charAt(j)){
          //然后比较顺序位置的字符是否都相等
          for(let m = i,n=j; m &lt; a.length &amp;&amp; n &lt; b.length; m++,n++){
            if(a.charAt(m) != b.charAt(n)){
              break;
            };
            //如果有更长的数值出现，重新赋值
            if(max_len &lt; m - i + 1){
              max_len =  m - i + 1
              console.log(max_len,i,m)
              maxLength_str = a.substring(i,m+1);
            }
          }
        }
      }
    }
    return maxLength_str;
  }
</code></pre></div><h3 id="_8-4-总结"><a href="#_8-4-总结" class="header-anchor">#</a> 8-4 总结</h3> <ul><li>在线性表表中，大多以‘单个元素’作为操作对象</li> <li>在字符串的基本操作中，通常以‘串的整体’作为操作对象</li> <li>字符串的增删操作和数组很像，复杂度也与之一样。但字符串的查找就复杂多了，这点经常被考察</li></ul> <blockquote><p>留下一个题，将c 重新按照 'blue is sky the'输出</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code> function s8_3(){
   let a = 'the sky is blue';
   let len = a.length
   let index = 0;
   let word = '';
   let result = '';
   //循环
   while(index &lt;  len){
     //跳过空格(这里需要一个循环，而不是if)
     while(index &lt; len &amp;&amp; a.charAt(index) == ' '){
       index ++
     }
     //组合单词
     while(index &lt; len &amp;&amp; a.charAt(index) !== ' '){
       word = `${word}${a.charAt(index)}`;
       index ++
       console.log(word,index)
     };
     result = word + ' ' + result;
     word = '';
   }
   return result.trim();
 }
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/senior-js/algorithm/data-structure/data-7.html" class="prev">
        7.数组：如何实现基本索引的查找
      </a></span> <span class="next"><a href="/senior-js/algorithm/data-structure/data-9.html">
        9.树和二叉树：如何实现增删改查
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.edd6bd2d.js" defer></script><script src="/assets/js/2.cff21c2a.js" defer></script><script src="/assets/js/23.2813ff38.js" defer></script>
  </body>
</html>
