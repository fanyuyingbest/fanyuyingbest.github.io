<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>13.排序：经典排序算法原理解析与对比 | 一只无聊的柠檬</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/img/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.3c3b5dfb.css" as="style"><link rel="preload" href="/assets/js/app.d60f4038.js" as="script"><link rel="preload" href="/assets/js/2.cff21c2a.js" as="script"><link rel="preload" href="/assets/js/15.439b8ec4.js" as="script"><link rel="prefetch" href="/assets/js/10.62788c6d.js"><link rel="prefetch" href="/assets/js/11.82446155.js"><link rel="prefetch" href="/assets/js/12.6cfbc28d.js"><link rel="prefetch" href="/assets/js/13.50063e85.js"><link rel="prefetch" href="/assets/js/14.fd706d55.js"><link rel="prefetch" href="/assets/js/16.a2199ef9.js"><link rel="prefetch" href="/assets/js/17.9ffa1e60.js"><link rel="prefetch" href="/assets/js/18.df5be67f.js"><link rel="prefetch" href="/assets/js/19.4895cf69.js"><link rel="prefetch" href="/assets/js/20.157086fd.js"><link rel="prefetch" href="/assets/js/21.45d105a4.js"><link rel="prefetch" href="/assets/js/22.8d3de896.js"><link rel="prefetch" href="/assets/js/23.c6be11b6.js"><link rel="prefetch" href="/assets/js/24.4953e3aa.js"><link rel="prefetch" href="/assets/js/25.c9fdc912.js"><link rel="prefetch" href="/assets/js/26.62eb5724.js"><link rel="prefetch" href="/assets/js/27.95deaeef.js"><link rel="prefetch" href="/assets/js/28.751f86e5.js"><link rel="prefetch" href="/assets/js/29.33059ca8.js"><link rel="prefetch" href="/assets/js/3.01d9f5e2.js"><link rel="prefetch" href="/assets/js/30.14c7e923.js"><link rel="prefetch" href="/assets/js/31.8048fd03.js"><link rel="prefetch" href="/assets/js/32.ce79a311.js"><link rel="prefetch" href="/assets/js/33.009ee4e0.js"><link rel="prefetch" href="/assets/js/34.ccbc73f3.js"><link rel="prefetch" href="/assets/js/35.f765c521.js"><link rel="prefetch" href="/assets/js/36.0c2d5f03.js"><link rel="prefetch" href="/assets/js/37.8f739f9a.js"><link rel="prefetch" href="/assets/js/38.c4ad125c.js"><link rel="prefetch" href="/assets/js/39.496b2aaf.js"><link rel="prefetch" href="/assets/js/4.d4d02f50.js"><link rel="prefetch" href="/assets/js/40.4afea906.js"><link rel="prefetch" href="/assets/js/5.079d44d2.js"><link rel="prefetch" href="/assets/js/6.fa7372c4.js"><link rel="prefetch" href="/assets/js/7.b43ba9af.js"><link rel="prefetch" href="/assets/js/8.14177bb9.js"><link rel="prefetch" href="/assets/js/9.66608647.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3c3b5dfb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">一只无聊的柠檬</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/senior-js/guide/" class="nav-link">
  工作总结
</a></div><div class="nav-item"><a href="/senior-js/algorithm/" class="nav-link router-link-active">
  自学记录
</a></div><div class="nav-item"><a href="/senior-js/readDoc/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/senior-js/other/" class="nav-link">
  杂谈
</a></div><div class="nav-item"><a href="https://github.com/fanyuyingbest" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/senior-js/guide/" class="nav-link">
  工作总结
</a></div><div class="nav-item"><a href="/senior-js/algorithm/" class="nav-link router-link-active">
  自学记录
</a></div><div class="nav-item"><a href="/senior-js/readDoc/" class="nav-link">
  读书笔记
</a></div><div class="nav-item"><a href="/senior-js/other/" class="nav-link">
  杂谈
</a></div><div class="nav-item"><a href="https://github.com/fanyuyingbest" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/senior-js/algorithm/" class="sidebar-link">知识体系梳理</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/senior-js/algorithm/2020/" class="sidebar-heading clickable"><span>2020年</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/senior-js/algorithm/data-structure/" class="sidebar-heading clickable router-link-active open"><span>数据结构-拉钩教育</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/senior-js/algorithm/data-structure/data-1.html" class="sidebar-link">1.复杂度：如何衡量程序运行的效率？</a></li><li><a href="/senior-js/algorithm/data-structure/data-2.html" class="sidebar-link">2.数据结构：时间复杂度👉空间复杂度</a></li><li><a href="/senior-js/algorithm/data-structure/data-3.html" class="sidebar-link">3.增删查：掌握数据结构基本操作</a></li><li><a href="/senior-js/algorithm/data-structure/data-4.html" class="sidebar-link">4.如何完成线性表结构下的增删查</a></li><li><a href="/senior-js/algorithm/data-structure/data-5.html" class="sidebar-link">5.栈：后进先出线性表实现增删查</a></li><li><a href="/senior-js/algorithm/data-structure/data-6.html" class="sidebar-link">6.队列：先进先出线性表实现增删查</a></li><li><a href="/senior-js/algorithm/data-structure/data-7.html" class="sidebar-link">7.数组：如何实现基本索引的查找</a></li><li><a href="/senior-js/algorithm/data-structure/data-8.html" class="sidebar-link">8.字符串：解决字符串匹配算法</a></li><li><a href="/senior-js/algorithm/data-structure/data-9.html" class="sidebar-link">9.树和二叉树：如何实现增删改查</a></li><li><a href="/senior-js/algorithm/data-structure/data-10.html" class="sidebar-link">10.哈希表：高效率查找的利器</a></li><li><a href="/senior-js/algorithm/data-structure/data-11.html" class="sidebar-link">11.递归：求解汉诺塔问题</a></li><li><a href="/senior-js/algorithm/data-structure/data-12.html" class="sidebar-link">12.分治：利用分治法完成数据查找</a></li><li><a href="/senior-js/algorithm/data-structure/data-13.html" class="active sidebar-link">13.排序：经典排序算法原理解析与对比</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/senior-js/algorithm/data-structure/data-14.html" class="sidebar-link">14.动态规划：最优结构解决复杂问题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/senior-js/algorithm/go/" class="sidebar-heading clickable"><span>数据结构-go</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/senior-js/algorithm/training/" class="sidebar-heading clickable"><span>每日一题</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_13-排序：经典排序算法原理解析与对比"><a href="#_13-排序：经典排序算法原理解析与对比" class="header-anchor">#</a> 13.排序：经典排序算法原理解析与对比</h1> <blockquote><p>之前章节我们学到了二分查找法，使用二分查找法要求原数组必须有序。所以，排序问题也是我们常见的一类问题。本章节我们就来学习常见的4种排序算法，包括冒泡排序、插入排序、归并排序以及快排序。</p></blockquote> <h3 id="_13-1-什么是排序问题"><a href="#_13-1-什么是排序问题" class="header-anchor">#</a> 13-1 什么是排序问题</h3> <blockquote><p><b>排序，就是让一组无序数组变成有序的过程(一般默认有序都是从小到大的排列顺序)</b>，下面我们来讲讲如何判断不同的排序算法优劣</p></blockquote> <ul><li>1.时间复杂度：具体包括最好时间复杂度，最坏时间复杂度以及平均时间复杂度</li> <li>2.空间复杂度：如果空间复杂度为1，也叫做原地排序</li> <li>3.稳定性：排序的稳定性是指相等的数据对象，在排序后，顺序是否能保证不变</li></ul> <h3 id="_13-2-常见的排序算法及其思想"><a href="#_13-2-常见的排序算法及其思想" class="header-anchor">#</a> 13-2 常见的排序算法及其思想</h3> <h4 id="_13-2-1-冒泡排序"><a href="#_13-2-1-冒泡排序" class="header-anchor">#</a> 13-2-1 冒泡排序</h4> <ul><li>1.冒泡排序的原理</li></ul> <blockquote><p><b>从第一个数据开始，依次比较相邻元素的大小。如果前者大于后者，则进行交换操作，把大的元素往后交换。通过多轮迭代，直到没有交换操作为止。</b>冒泡排序就像是一个水池中数据处理一样，每次会把最大的那个数据传递到最后</p></blockquote> <ul><li>2.冒泡排序的性能</li></ul> <blockquote><p><b>冒泡排序最好时间复杂度为O(n)</b>,也就是当输入数组刚好是顺序的时候，只需要挨个比较一遍就行，不需要做交换操作，所以时间复杂度为O(n).</p></blockquote> <blockquote><p>冒泡排序最坏时间复杂度会比较惨，是O(n<em>n).也就是说，当数组刚好是完全逆序的时候，每轮排序都需要挨个比较n次，并且重复n次，所以时间复杂度为O(n</em>n)</p></blockquote> <blockquote><p>当输入组杂乱无序时，它的平均时间复杂度也是O(n*n)</p></blockquote> <blockquote><p><b>冒泡排序不需要额外的空间，所以空间复杂度为O(1),冒泡排序过程中，当元素相同时不做交换，所以冒泡排序是稳定排序算法</b></p></blockquote> <div class="language- extra-class"><pre class="language-text"><code> function main(){
   let arr = [1,0,3,4,5,-6,7,8,9,10];
   document.write(`原始数据${arr}`);
   let isAsc = true;
   for(let i = 1; i &lt; arr.length; i++){
     //第一层循环
     for(let j = 0; j&lt; arr.length - i;j++){
       //第二层循环，转换数字类型
       console.log(Number(arr[j]) , Number(arr[j+1]))
       //比较前后两个数据大小，符合条件则交换位置
       if(Number(arr[j]) &gt; Number(arr[j+1])){
         let temp = arr[j];
         arr[j] = arr[j+1];
         arr[j+1] = temp;
       }
     }
   }
   document.write(`冒泡排序${arr}`);
 }
</code></pre></div><h4 id="_13-2-2-插入排序"><a href="#_13-2-2-插入排序" class="header-anchor">#</a> 13-2-2 插入排序</h4> <ul><li>1.插入排序的原理</li></ul> <blockquote><p><b>选取未排序元素，插入到已排序区间的合适位置，直到未排序区间为空</b>，插入排序顾名思义，就是从左到右维护一个已经排好序的序列。直到所有的待排数据全部完成插入动作。</p></blockquote> <ul><li>2.插入排序的性能
<ul><li>插入排序最好时间复杂度为O(n),即当数组刚好是完全顺序时，每次只用比较一次就能找到正确的位置，这个过程重复n次，就可以清空未排区间</li> <li>插入排序最坏时间复杂度则需要O(n<em>n).即当数组刚好完全逆序时，每次都要比较n次才能找到正确位置，这个过程重复n次，就可以清空未排序区间，所以最坏时间复杂度为O(n</em>n)</li> <li>插入排序的平均时间复杂度为O(n<em>n),这是因为往数组插入一个元素的平均时间复杂度为O(n),而插入排序可以理解为重复n次的数组插入操作，所以平均时间复杂度为O(n</em>n)</li> <li>插入排序不需要开辟额外的空间，所以时间复杂度是O(1)</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code> function main(){
   let arr = [2,3,5,1,23,6,78,34];
   document.write(`原始数据${arr}`);
   //i应该从1开始，j-i为0
   for(let i = 1;i &lt; arr.length;i++){
     //数组循环体
     var temp = arr[i];//取当前值为对比标准值
     var j = i - 1;//向前比较
     //与数组之前的元素做比较
     for(;j&gt;=0;j--){
       //如果当前的arr[j]大于arr[i],则应该交换位置
       if(Number(arr[j] &gt; Number(temp))){
         //arr[j+1]与arr[j]交换位置,这里是j+1 和j交换，不是和temp做交换
         arr[j+1] = arr[j];
       }else{
         //否则，跳出循环
         break
       }
     };
     //此时的j应该是循环里面最后一个值，如果符合，就是最小的值，比如i-2，0等，如果不符合，则是i-1;
     arr[j+1] = temp;
   }
   document.write(`插入排序结果${arr}`);
 }
</code></pre></div><p><b>小结：插入排序与冒泡排序算法的异同点</b></p> <ul><li><p>1.相同点</p> <ul><li>插入排序和冒泡排序的平均时间复杂度都是O(n*n),且都是稳定的排序算法，都属于原地排序</li></ul></li> <li><p>2.差异点</p> <ul><li>冒泡排序每轮交换操作都是动态的，所以需要三个赋值操作才能完成</li> <li>而插入排序每轮交换动作会固定待插入的数据，因此只需要一步赋值操作</li></ul></li></ul> <blockquote><p>以上两种排序算法都比较简单，通过这种算法可以帮助我们对排序的思想建立基本了解，接下来再介绍一些时间复杂度更低的排序算法，它们的时间复杂度可以达到O(nlogn)</p></blockquote> <h4 id="_13-2-3-归并排序"><a href="#_13-2-3-归并排序" class="header-anchor">#</a> 13-2-3 归并排序</h4> <ul><li>1.归并排序的原理</li></ul> <blockquote><p><b>归并排序的原理其实就是我们上一课时讲的分治法</b>，它首先将数组不断的二分，直到最后每个部分只包含1个数据。然后再对每个部分分别进行排序，最后将排序好的相邻两部分合并在一起，这样整个数组就有序了。</p></blockquote> <ul><li>2.归并排序的性能</li></ul> <blockquote><p><b>对于归并排序，它采用了二分迭代方式，复杂度为logn</b><br>
每次的迭代，需要两个有序数组进行合并，这样的动作在O(n)的时间复杂度下可以完成。因此，归并排序的复杂度是二者的乘积O(nlogn).同时，<b>它的执行频次与输入序列无关，因此，归并排序最好，最坏，平均时间复杂度都是O(nlogn).</b></p></blockquote> <blockquote><p><b>空间复杂度方面，由于每次合并的操作都需要开辟基于数组的临时内存空间，所以空间复杂度为O(n).归并排序合并的时候，相同元素的前后顺序不变，所以归并排序是稳定的排序算法</b></p></blockquote> <h4 id="_13-2-4-快速排序"><a href="#_13-2-4-快速排序" class="header-anchor">#</a> 13-2-4 快速排序</h4> <ul><li>1.快速排序的原理</li></ul> <blockquote><p><b>快速排序法的原理也是分治法</b>，它的每轮迭代，会选取数组中任意一个数据做为分区点，将小于它的元素放在左侧，大于它的放在右侧，再利用分治思想，继续分别对左右两侧进行同样的操作，直到每个区间缩小为1，则完成排序。</p></blockquote> <ul><li>2.快速排序的性能</li></ul> <blockquote><p><b>在快排的最好时间复杂度下，</b>如果每次选取分区点时，都能选中中位数，把数组等分为两个，那么此时<b>时间复杂度和归并一样，都是O(nlogn)</b></p></blockquote> <blockquote><p><b>在最坏时间复杂度下，也就是如果每次分区都选中了最小值和最大值，得到不均等的两组，那么就需要n次的分区操作，每次分区平均扫描n/2个元素，此时时间复杂度就是O(n*n)了</b></p></blockquote> <blockquote><p><b>快速排序法在大部分情况下，统计上是很难选到极端情况的，因此它平均的时间复杂度是O(nlogn)</b></p></blockquote> <blockquote><p><b>快速排序法在空间方面，使用了交换法，因此空间复杂度为O(1)</b></p></blockquote> <blockquote><p>很显然，快速排序的分区过程及交换操作，所以<b>快排是不稳定的排序算法</b></p></blockquote> <h3 id="_13-3-排序算法的性能分析"><a href="#_13-3-排序算法的性能分析" class="header-anchor">#</a> 13-3 排序算法的性能分析</h3> <ul><li>排序最暴力的方法，时间复杂度就是O(n*n),这恰如冒泡排序和插入排序</li> <li>当我们利用算法思维去解决问题时，就会想到使用分治法，此时，利用归并排序就能让时间复杂度降至O(nlogn).然而，归并排序需要额外开辟空间，一方面是为了稳定性，一方面是在归并时，由于在数组中插入元素导致了数据移挪问题。</li> <li>为了规避因此带来的时间损耗，此时我们采用快速排序。可以解决插入元素导致的移挪问题，而且降低了不必要的空间开销，但是由于二分交换数据，会导致得到的结果并不稳定。</li></ul> <h3 id="_13-4-总结"><a href="#_13-4-总结" class="header-anchor">#</a> 13-4 总结</h3> <ul><li>冒泡排序，插入排序，归并排序，快速排序；这些算法没有好坏之分，只是各有利弊，工作中可以根据实际情况选择最优算法</li> <li>如果对数据规模比较小的数据进行排序，可以选择时间复杂度为O(n<em>n)的排序算法。因为当数据结构小时，O(n</em>n)和O(nlogn)的差距只要几十毫秒，实际影响不大。</li> <li>但对于数据规模较大但数据进行排序时，就需要选择时间复杂度为O(nlogn)的排序算法</li> <li>归并排序的空间复杂度为O(n),也就意味着但排序100M的数据时，就需要200M的空间，所以对空间资源消耗会很多</li> <li>快速排序的平均时间复杂度为O(nlogn),但是如果分区选择的不好的话，最坏时间复杂度也有可能逼近O(n*n).而且快速排序不具备稳定性，这样需要看你所面对的问题是否有稳定性的要求</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/senior-js/algorithm/data-structure/data-12.html" class="prev">
        12.分治：利用分治法完成数据查找
      </a></span> <span class="next"><a href="/senior-js/algorithm/data-structure/data-14.html">
        14.动态规划：最优结构解决复杂问题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d60f4038.js" defer></script><script src="/assets/js/2.cff21c2a.js" defer></script><script src="/assets/js/15.439b8ec4.js" defer></script>
  </body>
</html>
